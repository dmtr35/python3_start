
# ============================================================================================================= #
#               https://github.com/ziishaned/learn-regex/blob/master/translations/README-ru.md                  #
# ============================================================================================================= #
# ============================================================================================================= #
# .         Точка соответствует любому отдельному символу, кроме перевода строки.                               #
# [ ]       Класс символов. Заменяет любой из символов, заключенных в квадратных скобках.                       #
# [^ ]      Отрицание класа символов. Соответствует любом символу, не содержащемуся в квадратных скобках.       #
# *         Искать 0 или более повторов предыдущего символа.                                                    #
# +         Искать 1 или более повторов предыдущего символа.                                                    #
# ?         Делает предыдущий символ необязательным.                                                            #
# {n,m}     Скобки. Искать не менее "n" и не более "m" повторов предыдущего символа.                            #
# (xyz)     Группа символов. Искать только символы xyz в указанном порядке.                                     #
# |         Чередование. Искать либо знаки до этого символа, либо знаки после символа.                          #
# \         Экранирование следующего символа. Позволяет искать специальные знаки: [ ] ( ) { } . * + ? ^ $ \ |   #
# ^         Обозначает начало пользовательского ввода.                                                          #
# $         Обозначает конец пользовательского ввода.                                                           #
# ============================================================================================================= #
# .         Любой символ, кроме символа перевода строки                                                         #
# \w        Английская буква либо цифра: [a-zA-Z0-9_]                                                           #
# \W        Любой символ, кроме английских букв и цифр: [^\w]                                                   #
# \d        Цифра: [0-9]                                                                                        #
# \D        Поиск всего, что не является цифрой: [^\d]                                                          #
# \s        Пробел либо символ начала строки: [\t\n\f\r\p{Z}]                                                   #
# \S        Любой символ, кроме пробела и символа начала строки: [^\s]                                          #
# ============================================================================================================= #
# ============================================================================================================= #

import re
# re.match()	   # Ищет только в начале строки  – возвращают объект типа Match
# re.search()	   # Ищет в любом месте строки (первое совпадение)  – возвращают объект типа Match
# re.findall()	   # Ищет все совпадения, возвращает список строк. Если в findall() есть группы в скобках (), то он возвращает только содержимое этих групп
# re.finditer()    # возвращает итератор (iterator) из объектов типа Match
# ----------------------------------------------------------------------

# res = re.search(".ar", "The car parked in the garage.")                         # находит первое вхождени <re.Match object; span=(4, 7), match='car'>
# print(res.group())                                                              # вернёт сам текст, который совпал. car
# print(res.start())                                                              # индекс начала совпадения → 4
# print(res.end())                                                                # индекс конца (НЕ включительно) → 7

# res = re.search("(.ar)", "The car parked.")
# print(res.group())                                                              # → 'car'
# print(res.groups())                                                             # вернёт все группы в виде кортежа → ('car',)

# res = re.search("([A-Za-z]+) (\d+)", "Order 1234")                              # \d - Цифра: [0-9]; + Искать 1 или более повторов предыдущего символа;
# print(res.group())                                                              # → 'Order 1234' (всё совпадение)
# print(res.groups())                                                             # → ('Order', '1234') (по группам)

# ----------------------------------------------------------------------
# Набор символов:
# print(re.findall("[Tt]he", "The car parked in the garage."))                   # находит все вхождения ['The', 'the']
# print(re.findall("ar[.]","A garage is a good place to park a car."))           # Точка внутри набора символов, обозначает непосредственно точку как символ ['ar.']
# print(re.findall("[^c]ar", "The car parked in the garage."))                   # ^ внутри скобок [] инвертирует набор символов → ['par', 'gar']

# ----------------------------------------------------------------------
# Повторения:
# print(re.findall("[a-z]*", "The car parked in the garage #21."))               # Символ * обозначает ноль или более повторений предыдущего символа
# print(re.findall("\s*cat\s*", "The fat cat sat on the concatenation."))        # ноль или более пробелов [' cat ', 'cat']
# print(re.findall("c.+t", "The fat cat sat on the mat."))                       # Символ + соответствует одному или более повторению предыдущего символа ['cat sat on the mat']

# print(re.findall("[T]he", "The car is parked in the garage."))                 # 
# print(re.findall("[T]?he", "The car is parked in the garage."))                # метасимвол ? делает предыдущий символ необязательным. ['The', 'he']

# ----------------------------------------------------------------------
# Фигурные скобки (квантификаторы):
# print(re.findall("[0-9]{2,3}", "The number was 9.9997 but we rounded it off to 10.0."))       # {} - сколько раз символ или группа символов могут повторяться ['999', '10']
# print(re.findall("[0-9]{2,}", "The number was 9.9997 but we rounded it off to 10.0."))        # {} - повтор симвова 2 или более раз ['9997', '10']
# print(re.findall("[0-9]{3}", "The number was 9.9997 but we rounded it off to 10.0."))         # {} - повтор ровно 3 символа ['999']

# ----------------------------------------------------------------------
# Скобочные группы — это группы подшаблонов, которые написаны в круглых скобках (...)
# matches = re.finditer("(c|g|p)ar", "The car is parked in the garage.")          # finditer возвращает итератор (iterator) из объектов типа Match
# result = [match.group() for match in matches]                                   # перебирает каждое совпадение, и match — это просто имя переменной в этом цикле.
# print(result)                                                                   # ['car', 'par', 'gar']

# print(re.findall("(?:c|g|p)ar", "The car is parked in the garage."))            # будет искать те же шаблоны, что и (c|g|p)ar, но группа захвата при этом создана не будет. ['car', 'par', 'gar']

# text = "My phone number is 123-456."
# match = re.search(r"(\d+)-(\d+)", text)
# print(match.group())                                                                # всё совпадение → '123-456'
# print(match.group(1))                                                               # первая группа → '123'
# print(match.group(2))                                                               # вторая группа → '456'

# ----------------------------------------------------------------------
# Перечисление:
# print(re.findall("(T|t)he|car", "The car is parked in the garage."))              # ['T', '', 't']
# print(re.findall("(?:T|t)he|car", "The car is parked in the garage."))            # ['The', 'car', 'the']

# text = "A big cat, a little dog, and a sneaky rat ran away."
# print(re.findall(r"\b(cat|dog|rat)\b", text))                                     # \b - это граница слова. ['The', 'car', 'the']

# animals = re.findall("(?:a|the)? (cat|dog|rat)", text)
# print(animals)

# print(re.findall(r"My number is (\d+)", "My number is 12345."))                    # возвращает только группы

# ----------------------------------------------------------------------

# Опережающие и ретроспективные проверки:
# ?=	Положительное опережающее условие
# print(re.findall("(?:T|t)he(?=\sfat)", "The fat cat sat on the mat."))            # Положительное опережающее условие. The должно быть перед пробелом и fat. ['The']
# print(re.findall(r"\w+(?=\.)", "nuke.net"))                                        # выводить если за выражением будет точка '.' -> ['nuke']

# ?!	Отрицательное опережающее условие
# print(re.findall("(?:T|t)he(?!\sfat)", "The fat cat sat on the mat."))            # Отрицательное опережающее условие. После The не должно быть пробела и fat. ['the']
# print(re.findall(r"\w+(?!\.)", "nuke.net"))                                         # выводить если за выражением не будет точки '.' -> ['nuk', 'net']

# ?<=	Положительное ретроспективное условие
# print(re.findall("(?<=(?:T|t)he\s)(fat|mat)", "The fat cat sat on the mat."))     # Положительное ретроспективное условие. Псовпадения, которым предшествует определенный шаблон. "найти все слова fat или mat из входной строки, которым предшествует слово The или the" ['fat', 'mat']
# print(re.findall(r"(?<=\.)\w+", "nuke.net"))                                      # выводить если перед выражением будет точка '.' -> ['net']

# ?<!	Отрицательное ретроспективное условие
# print(re.findall("(?<!(?:T|t)he\s)(cat)", "The fat cat sat on the mat."))         # Отрицательное ретроспективное условие. найти все слова cat из входной строки, которым не предшествует определенный артикль The или the" ['cat']
# print(re.findall(r"(?<!\.)\w+", "nuke.net"))                                      # выводить если перед выражением не будет точки '.' -> ['nuke', 'et']

# ----------------------------------------------------------------------
# Флаги (модификаторы):
# re.IGNORECASE	- Поиск без учета регистра.
# re.MULTILINE	- Мультистроковый поиск: якоря применяются к строкам, а не ко всему тексту. ^ - Начало каждой строки в тексте. $ - Конец каждой строки.

# Поиск без учета регистра:
# print(re.findall("The", "The fat cat sat on the mat."))                              
# print(re.findall(r"the", "The fat cat sat on the mat.", re.IGNORECASE))                           # re.I - игнорировать регистр символов. ['The', 'the']

# Мультистроковый поиск:
# text = """The cat
# sat on
# the mat"""
# print(re.findall(r"^the", text, re.I | re.M))                                                     # якоря ^ и $ работают в каждой строке ['The', 'the']

# ----------------------------------------------------------------------
# Жадная и ленивая квантификация, после повторителя ставится ? и он превращается в не жадный
# Жадная квантификация искать самые длинные возможные совпадения
# print(re.findall("(.*at)", "The fat cat sat on the mat."))            # по умолчанию жадное сопоставление. начиная с любой заканчивая t ['The fat cat sat on the mat']

# ленивая квантификация будет искать наименьшие возможные совпадения
# print(re.findall("(.*?at)", "The fat cat sat on the mat."))           # ленивая сопоставление. найкоротшие совпадения ['The fat', ' cat', ' sat', ' on the mat']
# print(re.findall(r"a+?b", "---aaabbb---"))                            # 
# print(re.findall(r"(a+?)(a)", "---aaabbb---"))                        # 
# print(re.findall(r"(a*?)(a+)", "---aaabbb---"))                       # 

# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# примеры search:
# res = re.search(r"((A+)\s*(B+))", "TheAAAA BBB fAAAt cBt. A BB AA")
# print(res.group())
# print(res.group(2))
# print(res.group(3))
# print(res.groups())

# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# примеры split:
# print(re.split(r"[.,\s-]+", "The fat cat, sat. On the mat"))             # разделили на части, удалив разделители ['The', 'fat', 'cat', 'sat', 'On', 'the', 'mat']
# print(re.split(r"([.,\s-]+)", "The fat cat, sat. On the mat"))           # чередуются ['The', ' ', 'fat', ' ', 'cat', ', ', 'sat', '. ', 'On', ' ', 'the', ' ', 'mat']

# ----------------------------------------------------------------------
# алчный повторитель(матчит всегда самый длинный фрагмент в подстроке) *+, ++, ?+ и {m,n}+
# (?>...) - общая конструкция алчной граппировки
# print(re.findall(r"(a*+)(\w)", "---aaabbb---"))                       # 

# ----------------------------------------------------------------------
# escape - Экранирование специальных символов в шаблоне
# print(re.escape("Whho. Shho"))                                          # Whho\.\ Shho
# print(re.escape("Whho. (Shho)."))                                       # Whho\.\ \(Shho\)\.






